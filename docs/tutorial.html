<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorial: Wrapping an NLP Application &mdash; clams-python  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="clams package" href="modules.html" />
    <link rel="prev" title="clams shell command" href="cli.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            clams-python
          </a>
              <div class="version">
                1.2.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="input-output.html">I/O Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="runtime-params.html">Runtime Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="appmetadata.html">CLAMS App Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="appdirectory.html">CLAMS App Directory</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli.html"><code class="docutils literal notranslate"><span class="pre">clams</span></code> shell command</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial: Wrapping an NLP Application</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-nlp-tool">The NLP tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wrapping-the-tokenizer">Wrapping the tokenizer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#imports">Imports</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-application-class">The application class</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#app-metadata">App Metadata</a></li>
<li class="toctree-l4"><a class="reference internal" href="#annotate"><code class="docutils literal notranslate"><span class="pre">_annotate()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#containerization-with-docker">Containerization with Docker</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#using-the-document-location-property">Using the <code class="docutils literal notranslate"><span class="pre">document.location</span></code> property</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">clams package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">clams-python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Tutorial: Wrapping an NLP Application</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tutorial-wrapping-an-nlp-application">
<span id="tutorial"></span><h1>Tutorial: Wrapping an NLP Application<a class="headerlink" href="#tutorial-wrapping-an-nlp-application" title="Permalink to this heading"></a></h1>
<p>The following is a tutorial on how to wrap a simple NLP tool as a CLAMS application, using app template generated by <code class="docutils literal notranslate"><span class="pre">clams</span> <span class="pre">develop</span></code> command.
Particularly, this article is focused on writing <code class="docutils literal notranslate"><span class="pre">_annotate()</span></code> method in a CLAMS app (<code class="docutils literal notranslate"><span class="pre">app.py</span></code>).
This may not make a lot of sense without glancing over recent <a class="reference external" href="https://mmif.clams.ai/">MMIF specifications</a> and <a class="reference external" href="introduction.html">CLAMS SDK overview</a>.</p>
<section id="the-nlp-tool">
<h2>The NLP tool<a class="headerlink" href="#the-nlp-tool" title="Permalink to this heading"></a></h2>
<p>We use an ultra simple tokenizer in <code class="docutils literal notranslate"><span class="pre">tokenizer.py</span></code> as the example NLP tool. All it does is define a tokenize function that uses a simple regular expression and returns a list of offset pairs.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">tok</span><span class="o">.</span><span class="n">span</span><span class="p">()</span> <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="s2">&quot;\w+&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)]</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s1">&#39;Fido barks.&#39;</span><span class="p">)</span>
<span class="go">[(0, 4), (5, 10)]</span>
</pre></div>
</div>
</section>
<section id="wrapping-the-tokenizer">
<h2>Wrapping the tokenizer<a class="headerlink" href="#wrapping-the-tokenizer" title="Permalink to this heading"></a></h2>
<p>First, it is recommended to call <code class="docutils literal notranslate"><span class="pre">clams</span> <span class="pre">develop</span></code> in the command line and follow the instructions there to generate the necessary skeleton templates for developing the app.</p>
<p>By convention, all the wrapping code is in a script named <code class="docutils literal notranslate"><span class="pre">app.py</span></code>, but this is not a strict requirement and you can give it another name. The <code class="docutils literal notranslate"><span class="pre">app.py</span></code> script does several things: (1) import the necessary code, (2) create a subclass of <code class="docutils literal notranslate"><span class="pre">ClamsApp</span></code> that defines the metadata and provides a method to run the wrapped NLP tool, and (3) provide a way to run the code as a HTTP Flask server. The template will generate the third part. Thus, the first and second parts of the code are explained here.</p>
<section id="imports">
<h3>Imports<a class="headerlink" href="#imports" title="Permalink to this heading"></a></h3>
<p>Aside from a few standard modules we need the following imports:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">clams.app</span> <span class="kn">import</span> <span class="n">ClamsApp</span>
<span class="kn">from</span> <span class="nn">clams.restify</span> <span class="kn">import</span> <span class="n">Restifier</span>
<span class="kn">from</span> <span class="nn">clams.appmetadata</span> <span class="kn">import</span> <span class="n">AppMetadata</span>
<span class="kn">from</span> <span class="nn">mmif.serialize</span> <span class="kn">import</span> <span class="n">Mmif</span>
<span class="kn">from</span> <span class="nn">mmif.vocabulary</span> <span class="kn">import</span> <span class="n">DocumentTypes</span>
<span class="kn">from</span> <span class="nn">lapps.discriminators</span> <span class="kn">import</span> <span class="n">Uri</span>
<span class="kn">import</span> <span class="nn">tokenizer</span>
</pre></div>
</div>
<p>For non-NLP CLAMS applications we would also do  <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">mmif.vocabulary</span> <span class="pre">import</span> <span class="pre">AnnotationTypes</span></code>, but this is not needed for NLP applications because they do not need the CLAMS vocabulary. What we do need to import are the URIs of all LAPPS annotation types and the NLP tool itself.</p>
<p>Importing <code class="docutils literal notranslate"><span class="pre">lapps.discriminators.Uri</span></code> is for convenience since it gives us easy access to the URIs of annotation types and some of their attributes. The following code prints a list of available variables that point to URIs:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lapps.discriminators</span> <span class="kn">import</span> <span class="n">Uri</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">Uri</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">Uri</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;org/ns&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attrs</span><span class="p">))</span>
<span class="go">ANNOTATION CHUNK CONSTITUENT COREF DATE DEPENDENCY DEPENDENCY_STRUCTURE DOCUMENT GENERIC_RELATION LEMMA LOCATION LOOKUP MARKABLE MATCHES NCHUNK NE ORGANIZATION PARAGRAPH PERSON PHRASE_STRUCTURE POS RELATION SEMANTIC_ROLE SENTENCE TOKEN VCHUNK</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Uri</span><span class="o">.</span><span class="n">TOKEN</span><span class="p">)</span>
<span class="go">http://vocab.lappsgrid.org/Token</span>
</pre></div>
</div>
</section>
<section id="the-application-class">
<h3>The application class<a class="headerlink" href="#the-application-class" title="Permalink to this heading"></a></h3>
<p>With the imports in place we define a subclass of <code class="docutils literal notranslate"><span class="pre">ClamsApp</span></code> which needs two methods:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TokenizerApp</span><span class="p">(</span><span class="n">ClamsApp</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_appmetadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mmif</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>Here it is useful to introduce some background. The CLAMS HTTP API connects the GET and POST requests to the <code class="docutils literal notranslate"><span class="pre">appmetdata()</span></code>  and  <code class="docutils literal notranslate"><span class="pre">annotate()</span></code> methods on the app respectively, and those methods are both defined in <code class="docutils literal notranslate"><span class="pre">ClamsApp</span></code>. In essence, they are wrappers around  <code class="docutils literal notranslate"><span class="pre">_appmetadata()</span></code> and   <code class="docutils literal notranslate"><span class="pre">_annotate()</span></code> and provide some common functionality like making sure the output is serialized into a string.</p>
<section id="app-metadata">
<h4>App Metadata<a class="headerlink" href="#app-metadata" title="Permalink to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">_appmetadata()</span></code> method should return an <code class="docutils literal notranslate"><span class="pre">AppMetadata</span></code> object that defines the relevant metadata for the app:</p>
<p>(If you are using the app template, use <code class="docutils literal notranslate"><span class="pre">metadata.py</span></code> instead of <code class="docutils literal notranslate"><span class="pre">app.py</span></code> to define the metadata.)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">APP_LICENSE</span> <span class="o">=</span> <span class="s1">&#39;Apache 2.0&#39;</span>
<span class="n">TOKENIZER_LICENSE</span> <span class="o">=</span> <span class="s1">&#39;Apache 2.0&#39;</span>
<span class="n">TOKENIZER_VERSION</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">__VERSION__</span>

<span class="k">def</span> <span class="nf">_appmetadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">AppMetadata</span><span class="p">(</span>
        <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;tokenizer&#39;</span><span class="p">,</span>
        <span class="n">url</span><span class="o">=</span><span class="s1">&#39;https://github.com/clamsproject/app-nlp-example&#39;</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Simplistic Tokenizer&quot;</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Apply simple tokenization to all text documents in a MMIF file.&quot;</span><span class="p">,</span>
        <span class="n">app_license</span><span class="o">=</span><span class="n">APP_LICENSE</span><span class="p">,</span>
        <span class="n">analyzer_version</span><span class="o">=</span><span class="n">TOKENIZER_VERSION</span><span class="p">,</span>
        <span class="n">analyzer_license</span><span class="o">=</span><span class="n">TOKENIZER_LICENSE</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">metadata</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">DocumentTypes</span><span class="o">.</span><span class="n">TextDocument</span><span class="p">)</span>
    <span class="n">metadata</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">Uri</span><span class="o">.</span><span class="n">TOKEN</span><span class="p">)</span>
    <span class="n">metadata</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;Throw error if set to True&#39;</span><span class="p">,</span> <span class="s1">&#39;boolean&#39;</span><span class="p">)</span>
    <span class="n">metadata</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s1">&#39;eol&#39;</span><span class="p">,</span> <span class="s1">&#39;Insert sentence boundaries&#39;</span><span class="p">,</span> <span class="s1">&#39;boolean&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">metadata</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>Warning</strong>
When using the separately generated <code class="docutils literal notranslate"><span class="pre">metadata.py</span></code> created via <code class="docutils literal notranslate"><span class="pre">clams</span> <span class="pre">develop</span></code>, this method within <code class="docutils literal notranslate"><span class="pre">app.py</span></code> should be left empty with a <code class="docutils literal notranslate"><span class="pre">pass</span></code> statement as shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_appmetadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># When using the ``metadata.py`` leave this do-nothing &quot;pass&quot; method here.</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>And the <code class="docutils literal notranslate"><span class="pre">appmetadata()</span></code> within <code class="docutils literal notranslate"><span class="pre">metadata.py</span></code> should be implemented instead. Follow the instructions in the template.</p>
<p><strong>Note</strong>
Also refer to <a class="reference external" href="https://sdk.clams.ai/appmetadata.html">CLAMS App Metadata</a> for more details regarding what fields need to be specified.</p>
</div></blockquote>
</section>
<section id="annotate">
<h4><code class="docutils literal notranslate"><span class="pre">_annotate()</span></code><a class="headerlink" href="#annotate" title="Permalink to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">_annotate()</span></code> method should accept a MMIF file/string/object as its first parameter and always returns a <code class="docutils literal notranslate"><span class="pre">MMIF</span></code> object with an additional <code class="docutils literal notranslate"><span class="pre">view</span></code> containing annotation results. This is where the bulk of your logic will go. For a text processing app, it is mostly concerned with finding text documents, calling the code that runs over the text, creating new views and inserting the results.</p>
<p>In addition to the input MMIF, this method can accept any number of keyword arguments, which are the parameters set by the user/caller. Note that when this method is called inside the <code class="docutils literal notranslate"><span class="pre">annotate()</span></code> public method in the <code class="docutils literal notranslate"><span class="pre">ClamsApp</span></code> class (which is the usual case when running as a CLAMS app), the keyword arguments are automatically “refined” before being passed here. The refinement includes</p>
<ol class="arabic simple">
<li><p>inserting “default” values for parameters that are not set by the user</p></li>
<li><p>checking that the values are of the correct type and value, based on the parameter specification in the app metadata</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mmif</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># then, access the parameters: here to just print</span>
    <span class="c1"># them and to willy-nilly throw an error if the caller wants that</span>
    <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">configs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Parameter </span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
        <span class="c1"># as we defined this `error` parameter in the app metadata</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="s1">&#39;error&#39;</span> <span class="ow">and</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Exception - </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">configs</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">])</span>
    <span class="c1"># Initialize the MMIF object from the string if needed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mmif</span> <span class="o">=</span> <span class="n">mmif</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mmif</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Mmif</span> <span class="k">else</span> <span class="n">Mmif</span><span class="p">(</span><span class="n">mmif</span><span class="p">)</span>
    <span class="c1"># process the text documents in the documents list</span>
    <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mmif</span><span class="o">.</span><span class="n">get_documents_by_type</span><span class="p">(</span><span class="n">DocumentTypes</span><span class="o">.</span><span class="n">TextDocument</span><span class="p">):</span>
        <span class="n">new_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># _run_nlp_tool() is the method that does the actual work</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_nlp_tool</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">new_view</span><span class="p">,</span> <span class="n">doc</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
    <span class="c1"># return the MMIF object</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mmif</span>
</pre></div>
</div>
<p>For language processing applications, one task is to retrieve all text documents from both the documents list and the views. Annotations generated by the NLP tool need to be anchored to the text documents, which in the case of text documents in the documents list is done by using the text document identifier, but for text documents in views we also need the view identifier. A view may have many text documents and typically all annotations created will be put in one view.</p>
<p>For each text document from the document list, there is one invocation of <code class="docutils literal notranslate"><span class="pre">_new_view()</span></code> which gets handed a document identifier, so it can be put in the view metadata. And for each view with text documents there is also one invocation of <code class="docutils literal notranslate"><span class="pre">_new_view()</span></code>, but no document identifier is handed in so the identifier will not be put into the view metadata.</p>
<p>The method  <code class="docutils literal notranslate"><span class="pre">_run_nlp_tool()</span></code> is responsible for running the NLP tool and adding annotations to the new view. The third argument allows us to anchor annotations created by the tool by handing over the document identifier, possibly prefixed by the view the document lives in.</p>
<p>One thing about <code class="docutils literal notranslate"><span class="pre">_annotate()</span></code> as it is defined above is that it will most likely be the same for each NLP application, all the application specific details are in the code that creates new views and the code that adds annotations.</p>
<section id="creating-a-new-view">
<h5>Creating a new view:<a class="headerlink" href="#creating-a-new-view" title="Permalink to this heading"></a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">runtime_config</span><span class="p">):</span>
    <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mmif</span><span class="o">.</span><span class="n">new_view</span><span class="p">()</span>
    <span class="n">view</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">identifier</span>
    <span class="c1"># first thing you need to do after creating a new view is &quot;sign&quot; the view</span>
    <span class="c1"># the sign_view() method will record the app&#39;s identifier and the timestamp</span>
    <span class="c1"># as well as the user parameter inputs. This is important for reproducibility.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sign_view</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">runtime_config</span><span class="p">)</span>
    <span class="c1"># then record what annotations you want to create in this view</span>
    <span class="n">view</span><span class="o">.</span><span class="n">new_contain</span><span class="p">(</span><span class="n">Uri</span><span class="o">.</span><span class="n">TOKEN</span><span class="p">,</span> <span class="n">document</span><span class="o">=</span><span class="n">docid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">view</span>
</pre></div>
</div>
<p>This is the simplest NLP view possible since there is only one annotation type and it has no metadata properties beyond the <code class="docutils literal notranslate"><span class="pre">document</span></code> property. Other applications may have more annotation types, which results in repeated invocations of <code class="docutils literal notranslate"><span class="pre">new_contain()</span></code>, and may define other metadata properties for those types.</p>
</section>
<section id="adding-annotations">
<h5>Adding annotations:<a class="headerlink" href="#adding-annotations" title="Permalink to this heading"></a></h5>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_run_nlp_tool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">new_view</span><span class="p">,</span> <span class="n">full_doc_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run the NLP tool over the document and add annotations to the view, using the</span>
<span class="sd">    full document identifier (which may include a view identifier) for the document</span>
<span class="sd">    property.&quot;&quot;&quot;</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">text_value</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">new_view</span><span class="o">.</span><span class="n">new_annotation</span><span class="p">(</span><span class="n">Uri</span><span class="o">.</span><span class="n">TOKEN</span><span class="p">)</span>
        <span class="c1"># no need to do this for documents in the documents list</span>
        <span class="k">if</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">full_doc_id</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s1">&#39;document&#39;</span><span class="p">,</span> <span class="n">full_doc_id</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="n">p1</span><span class="p">:</span><span class="n">p2</span><span class="p">])</span>
</pre></div>
</div>
<p>First, with <code class="docutils literal notranslate"><span class="pre">text_value</span></code> we get the text from the text document, either from its <code class="docutils literal notranslate"><span class="pre">location</span></code> property or from its <code class="docutils literal notranslate"><span class="pre">text</span></code> property. Second, we apply the tokenizer to the text. And third, we loop over the token offsets in the tokenizer result and create annotations of type <code class="docutils literal notranslate"><span class="pre">Uri.TOKEN</span></code> with an identifier that is automatically generated by the SDK. All that is needed for adding an annotation is the <code class="docutils literal notranslate"><span class="pre">new_annotation()</span></code> method on the view object and the <code class="docutils literal notranslate"><span class="pre">add_property()</span></code> method on the annotation object.</p>
</section>
</section>
</section>
</section>
<section id="containerization-with-docker">
<h2>Containerization with Docker<a class="headerlink" href="#containerization-with-docker" title="Permalink to this heading"></a></h2>
<p>Apps within CLAMS typically run as Flask servers in Docker containers, and after an app is tested as a local Flask application it should be containerized. In fact, in some cases we don’t even bother running a local Flask server and move straight to the container set up.</p>
<p>Three configuration files for building a container image should be automatically generated through the <code class="docutils literal notranslate"><span class="pre">clams</span> <span class="pre">develop</span></code> command:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>file</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Containerfile</p></td>
<td><p>Describes how to create a container image for this application.</p></td>
</tr>
<tr class="row-odd"><td><p>.dockerignore</p></td>
<td><p>Specifies which files are not needed for running this application.</p></td>
</tr>
<tr class="row-even"><td><p>requirements.txt</p></td>
<td><p>File with all Python modules that need to be installed.</p></td>
</tr>
</tbody>
</table>
<p>Here is the minimal Containerfile included with this example:</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="c"># make sure to use a specific version number here</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">ghcr.io/clamsproject/clams-python:x.y.z</span>
<span class="k">WORKDIR</span><span class="w"> </span><span class="s">./app</span>
<span class="k">COPY</span><span class="w"> </span>./<span class="w"> </span>./
<span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;python3&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;app.py&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>This starts from the base CLAMS image which is created from an official Python image (Debian-based) with the clams-python package and the code it depends on added. The Containerfile only needs to be edited if additional installations are required to run the NLP tool. In that case the Containerfile will have a few more lines:</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="w"> </span><span class="s">ghcr.io/clamsproject/clams-python:x.y.z</span>
<span class="k">RUN</span><span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>-y<span class="w"> </span>&lt;system-packages&gt;
<span class="k">WORKDIR</span><span class="w"> </span><span class="s">./app</span>
<span class="k">COPY</span><span class="w"> </span>./requirements.txt<span class="w"> </span>.
<span class="k">RUN</span><span class="w"> </span>pip3<span class="w"> </span>install<span class="w"> </span>-r<span class="w"> </span>requirements.txt
<span class="k">COPY</span><span class="w"> </span>./<span class="w"> </span>./
<span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;python3&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;app.py&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>With this Containerfile you typically only need to make changes to the requirements file for additional python installs.</p>
<p>This repository also includes a <code class="docutils literal notranslate"><span class="pre">.dockerignore</span></code> file. Editing it is optional, but with large repositories with lots of documentation and images you may want to add some file paths just to keep the image as small as possible.</p>
<p>Use one of the following commands to build the image, the first one builds an image with a production server using Gunicorn, the second one builds a development server using Flask.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>clams-nlp-example:0.0.1<span class="w"> </span>-f<span class="w"> </span>Containerfile<span class="w"> </span>.
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">-t</span></code> option lets you pick a name and a tag for the image. You can use another name if you like. You do not have to add a tag and you could just use <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">nlp-clams-example</span></code>, but it is usually a good idea to use the version name as the tag.
The <code class="docutils literal notranslate"><span class="pre">-f</span></code> option lets you specify a different Containerfile. If you do not specify a file then <code class="docutils literal notranslate"><span class="pre">docker</span></code> will look for a file called <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> in the current directory (Note that in this tutorial we’re using <code class="docutils literal notranslate"><span class="pre">Containerfile</span></code> as the name, not <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>).</p>
<p>To test the Flask app in the container do</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>docker<span class="w"> </span>run<span class="w"> </span>--rm<span class="w"> </span>-it<span class="w"> </span>clams-nlp-example:0.0.1<span class="w"> </span>bash
</pre></div>
</div>
<p>You are now running a bash shell in the container and in the container you can run</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>root@c85a08b22f18:/app#<span class="w"> </span>python<span class="w"> </span>test.py<span class="w"> </span>input/example-1.mmif<span class="w"> </span>out.json
</pre></div>
</div>
<p>Escape out of the container with Ctrl-d.</p>
<p>To test the Flask app in the container from your local machine do</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>docker<span class="w"> </span>run<span class="w"> </span>--name<span class="w"> </span>clams-nlp-example<span class="w"> </span>--rm<span class="w"> </span>-d<span class="w"> </span>-p<span class="w"> </span><span class="m">5000</span>:5000<span class="w"> </span>clams-nlp-example:0.0.1
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">--name</span></code> option gives a name to the container which we use later to stop it (if we do not name the container then <code class="docutils literal notranslate"><span class="pre">docker</span></code> will generate a name, and we have to query <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">ps</span></code> to see what containers are running and then use that name to stop it). Now you can use curl to send requests (not sending the -h headers for brevity, it does work without them):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>curl<span class="w"> </span>http://localhost:5000/
$<span class="w"> </span>curl<span class="w"> </span>-X<span class="w"> </span>POST<span class="w"> </span>-d@input/example-1.mmif<span class="w"> </span>http://localhost:5000/
</pre></div>
</div>
<section id="using-the-document-location-property">
<h3>Using the <code class="docutils literal notranslate"><span class="pre">document.location</span></code> property<a class="headerlink" href="#using-the-document-location-property" title="Permalink to this heading"></a></h3>
<p>Typically <code class="docutils literal notranslate"><span class="pre">TextDocument</span></code> in a MMIF use the location property to point to a text file. This will not work with the setup laid out above because that’s dependent on having a local path on your machine and the container has no access to that path. What you need to do is to make sure that the container can see the data on your local machine and you can use the <code class="docutils literal notranslate"><span class="pre">-v</span></code> option for that:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>docker<span class="w"> </span>run<span class="w"> </span>--name<span class="w"> </span>clams-nlp-example<span class="w"> </span>--rm<span class="w"> </span>-d<span class="w"> </span>-p<span class="w"> </span><span class="m">5000</span>:5000<span class="w"> </span>-v<span class="w"> </span><span class="nv">$PWD</span>/input/data:/data<span class="w"> </span>clams-nlp-example:0.0.1
</pre></div>
</div>
<p>We now have specified that the <code class="docutils literal notranslate"><span class="pre">/data</span></code> directory on the container is a mount of the <code class="docutils literal notranslate"><span class="pre">./input/data</span></code> directory in the “host” machine. Given that <code class="docutils literal notranslate"><span class="pre">./input/data</span></code> contains a <code class="docutils literal notranslate"><span class="pre">example.txt</span></code> text file, now you need to make sure that the input MMIF file uses the path on the container:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;@type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;http://mmif.clams.ai/vocabulary/TextDocument/v1&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;properties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;m1&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;mime&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;text/plain&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;location&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/data/text/example.txt&quot;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To generate a MMIF file like this, you can use <code class="docutils literal notranslate"><span class="pre">clams</span> <span class="pre">source</span></code> command from your shell.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>clams<span class="w"> </span><span class="nb">source</span><span class="w"> </span>--prefix<span class="w"> </span>/data/input<span class="w"> </span>text:example.txt
<span class="o">{</span>
<span class="w">  </span><span class="s2">&quot;metadata&quot;</span>:<span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="s2">&quot;mmif&quot;</span>:<span class="w"> </span><span class="s2">&quot;http://mmif.clams.ai/1.0.0&quot;</span>
<span class="w">  </span><span class="o">}</span>,
<span class="w">  </span><span class="s2">&quot;documents&quot;</span>:<span class="w"> </span><span class="o">[</span>
<span class="w">    </span><span class="o">{</span>
<span class="w">      </span><span class="s2">&quot;@type&quot;</span>:<span class="w"> </span><span class="s2">&quot;http://mmif.clams.ai/vocabulary/TextDocument/v1&quot;</span>,
<span class="w">      </span><span class="s2">&quot;properties&quot;</span>:<span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="s2">&quot;mime&quot;</span>:<span class="w"> </span><span class="s2">&quot;text&quot;</span>,
<span class="w">        </span><span class="s2">&quot;id&quot;</span>:<span class="w"> </span><span class="s2">&quot;d1&quot;</span>,
<span class="w">        </span><span class="s2">&quot;location&quot;</span>:<span class="w"> </span><span class="s2">&quot;file:///data/input/example.txt&quot;</span>
<span class="w">      </span><span class="o">}</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">  </span><span class="o">]</span>,
<span class="w">  </span><span class="s2">&quot;views&quot;</span>:<span class="w"> </span><span class="o">[]</span>
<span class="o">}</span>
</pre></div>
</div>
<p>And now you can use curl again</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>curl<span class="w"> </span>-X<span class="w"> </span>POST<span class="w"> </span>-d@input/example-3.mmif<span class="w"> </span>http://0.0.0.0:5000/
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="cli.html" class="btn btn-neutral float-left" title="clams shell command" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="modules.html" class="btn btn-neutral float-right" title="clams package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Brandeis LLC.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>