#!/usr/bin/env python3
"""
The purpose of this file is to define 
a thin CLI interface for your app

DO NOT CHANGE the name of the file
"""


# Imports
import argparse
import json
import sys 

from typing import Dict, Union

from app import ClamsApp, AppMetadata, get_app
from mmif import Mmif
# Dict to convert parameter types to python types
type_map = {
    "integer": int,
    "number": float,
    "string": str,
    "boolean": bool,
    "map": dict,
}
# ============================================================|
def parse_metadata(app_metadata: AppMetadata) -> Dict[str, Union[str, float, int, bool, dict]]:
    """Separate argparser for runtime parameters,

    uses parameters accessible via `metadata.py` to
    construct the argparse arguments, parses them,
    and converts them to a dictionary of values before returning
    """

    # helper function for argparse 'nargs' field
    def _get_nargs(param):
        if param.multivalued:
            return "?" if param.type == "boolean" else "+"
        return 1

    parser = argparse.ArgumentParser(add_help=False,
        description="Command-Line Interface for CLAMS app"
    )

    # keep track of dict-type values in parameters for later parsing
    maps = set()

    # parse cli args from app parameters
    for parameter in app_metadata["parameters"]:
        if type_map[parameter.type] == dict:
            maps.add(parameter.name)
        parser.add_argument(
            f"--{parameter.name}",
            help=parameter.description,
            nargs=_get_nargs(parameter),
            type=type_map[parameter.type],
            choices=parameter.choices,
            default=parameter.default,
            action="store",
        )

    # namespace -> dictionary
    app_args = vars(parser.parse_args())

    # convert dict-type arg strings into k/v pairs
    for arg, val in app_args.items():
        if arg in maps:
            app_args[arg] = {k: v for k, v in [pair.split(":") for pair in val]}

    return app_args


def main():
    # CLI pipeline: `stdin` -> app._annotate -> `stdout`
    input = sys.stdin

    # Load data from stdin 
    in_data = Mmif("".join([line.rstrip("\n") for line in input]))

    # Load app from `app.py` constructor and get runtime params
    clamsapp: ClamsApp = get_app()
    app_metadata = dict(json.loads(clamsapp.appmetadata()))
    runtime_parameters = parse_metadata(app_metadata=app_metadata)

    # Write _annotate output (mmif) to stdout
    print(clamsapp._annotate(in_data, **runtime_parameters), file=sys.stdout)

if __name__ == "__main__":
    main()